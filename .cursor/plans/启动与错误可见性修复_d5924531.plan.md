---
name: 启动与错误可见性修复
overview: 在 run.py 最早处接入 bootstrap 日志、在服务线程与托盘处统一捕获并记录异常，并增加带控制台的调试版 exe，确保“无法打开/无托盘”时也有可分析的报错信息；随后按流程重新调试与打包。
todos: []
isProject: false
---

# 启动失败与错误不可见问题修复计划

## 问题根因简述

- **日志只在 `run_server()` 里初始化**，而 GUI 模式下 `run_server()` 在**后台线程**中执行；主线程先执行 `run_tray()`。若托盘在初始化或运行时就失败（如 pystray/PIL 的 `ImportError` 或 `icon.run()` 抛错），会直接退出且**尚未写入任何日志**，或日志文件尚未创建。
- **托盘静默退出**：[tray_service.py](backend/services/tray_service.py) 中 `except ImportError: return` 导致无 pystray/PIL 时直接返回，主线程结束、进程退出，无任何提示。
- **后台线程异常未被记录**：`run.py` 中 `run_api()` 仅调用 `run_server(port=port)`，若 `run_server` 或 uvicorn 抛错，异常只存在于后台线程，未写入日志或控制台；打包后无控制台，用户看不到任何输出。

因此会出现“无法正常打开、右下角无托盘、日志里也没有明显报错”的现象。

---

## 1. Bootstrap 日志（最早落盘，便于分析）

**目标**：在**不依赖 backend 或任何可能失败导入**的前提下，在进程内最早可执行点写一条“启动记录”到固定日志文件，并在此后所有关键步骤/异常时追加写入，保证任意阶段出错都有迹可查。

**实现要点**：

- 在 [run.py](run.py) 的 `if __name__ == "__main__":` 中，**解析完 argparse 之后、其余逻辑之前**，增加“bootstrap 写日志”逻辑：
  - 仅使用 `os`、`sys`、`time` 等标准库。
  - 日志目录与文件名与现有一致：`%APPDATA%\\WindowsCleaner\\logs\\windows_cleaner.log`（与 [backend/core/constants.py](backend/core/constants.py) 中 CONFIG_DIR 约定一致，用 `os.environ.get("APPDATA","")` + `"WindowsCleaner"` 拼接，避免此时 import backend）。
  - 若目录不存在则 `os.makedirs(..., exist_ok=True)`，然后以追加模式打开该文件，写入一行：时间戳 + `"bootstrap started"` + `frozen=...` + `gui=...` + `port=...`，并 `flush()`。
  - 后续所有“关键步骤”和“捕获到的异常”均以**同一文件、追加写入**的方式记录（时间戳 + 简短描述 + 若有异常则 `traceback.format_exc()`），便于你或后续分析时从一条时间线还原启动过程与报错。

这样即使 backend 导入失败、或服务器线程从未跑到 `setup_logging()`，也能在日志文件中看到“已启动”以及后续任何一步的报错信息。

---

## 2. 主流程异常捕获与写入 bootstrap 日志

**目标**：主线程内所有可能导致“无界面、无托盘”的异常都写入上述 bootstrap 日志，并尽量注明步骤，方便定位。

**实现要点**：

- 在 [run.py](run.py) 中，将“解析参数 → _kill_old_instances → 判断 gui → 启动服务器线程 → sleep → _disk_check_callback → Timer(_open_main_window) → run_tray()”整段逻辑包在一个 `try/except` 中：
  - 在关键步骤后追加写 bootstrap 日志（例如：`kill_old done`、`gui mode`、`server thread started`、`about to run_tray`）。
  - `except Exception` 时：将 `traceback.format_exc()` 与简短说明（如 "main thread failed"）追加写入同一 bootstrap 日志文件，再 `raise` 或 `sys.exit(1)`，避免静默退出。
- 若希望“出错时用户能知道看日志”，可在捕获到异常并写入日志后，尝试用 `ctypes.windll.user32.MessageBoxW` 弹出提示，内容包含“启动失败，请查看日志：<日志路径>”（仅 Windows、且不依赖 backend）。

这样“无法打开、无托盘”时，至少日志里会有一条明确的异常栈，便于你根据报错信息自行分析。

---

## 3. 服务器线程异常写入日志

**目标**：后台线程中 `run_server()` 或 uvicorn 的异常不再“只存在于线程内”，而是落盘到同一日志文件。

**实现要点**：

- 在 [run.py](run.py) 中，将 `run_api()` 改为：
  - 先尝试调用一次 **仅做日志初始化** 的轻量逻辑（例如在 run.py 内先调用 [backend/core/logging_config.py](backend/core/logging_config.py) 的 `setup_logging()`，若成功则后续 run_server 内可不再重复初始化，或保留 run_server 内现有 setup_logging 作为兼容）；若在 run_api 内调用 setup_logging 会引入 import backend，则改为在 run_api 内用 try/except 包住 `run_server(port=port)`，在 except 中把异常写入 **bootstrap 日志文件**（同一路径，append + traceback），这样即使 run_server 在 setup_logging 之前就抛错，也有记录。
  - 在 `run_api()` 内：`try: run_server(port=port) except Exception: ...`，将异常信息与 `traceback.format_exc()` 写入上述 bootstrap 日志文件（或已初始化好的 logging_config 的 logger），然后可 re-raise 或不再 raise（避免 daemon 线程吞掉异常导致主进程无感知；若 re-raise，主进程需通过其他方式感知，例如设置一个“server_failed”标志供主线程轮询或日志中可见即可）。

推荐：在 run.py 主流程里**先**（在启动 server 线程之前）调用一次 `setup_logging()`，这样主线程和 server 线程都能尽早使用同一套日志；若 import 或 setup_logging 失败，则把该异常写入 bootstrap 文件。这样“出错也有报错信息可以给到你自己进行分析”即可满足。

---

## 4. 托盘启动失败必须写日志并可选弹窗

**目标**：托盘若因 ImportError 或 icon.run() 抛错而无法显示，不再静默 return，而是写日志并可选弹窗提示用户查看日志。

**实现要点**：

- 在 [backend/services/tray_service.py](backend/services/tray_service.py) 的 `run_tray()` 中：
  - 将 `except ImportError: return` 改为：写入日志（若此时 logging 已初始化则用 get_logger；否则接受一个可选参数 `bootstrap_log_path` 或通过模块级方式获取 run.py 的 bootstrap 路径，向该文件 append 一行 "tray: ImportError (pystray/PIL missing)" + 可选 traceback），然后再 return。
  - 用 try/except 包住 `icon.run()` 及之前所有托盘相关代码（创建 icon、菜单、线程等）：一旦异常，同样将异常信息写入上述日志（或 bootstrap 文件），再 raise 或 return。
- 在 [run.py](run.py) 中调用 `run_tray()` 时：
  - 若希望“托盘失败时用户能发现”，可在 run_tray 返回后检查“是否本应显示托盘却提前返回”（例如通过 run_tray 的返回值或一个共享状态表示“托盘未正常启动”），然后向 bootstrap 日志追加一行，并可选弹出 MessageBox 提示“托盘未启动，请查看日志：<路径>”。

这样“右下角没有出现软件托盘”时，日志里会有明确原因（如缺少依赖或 icon.run 报错），便于你根据报错信息分析。

---

## 5. 带控制台的调试版 exe（便于你本地复现与查看报错）

**目标**：在保留现有无控制台 exe 的前提下，增加一个“带控制台”的构建产物，便于你本地双击运行后直接看到 print 与未捕获异常，方便调试和把报错信息提供给分析。

**实现要点**：

- 复制或复用现有 [WindowsCleaner.spec](WindowsCleaner.spec)，生成一份例如 `WindowsCleaner_console.spec`（或通过 build 参数区分）：
  - 将 `EXE(..., console=False, ...)` 改为 `console=True`，输出 exe 命名为 `WindowsCleaner_console.exe`。
- 在 [packaging/build_exe.py](packaging/build_exe.py) 中：
  - 支持一个参数（如 `--debug` 或 `--console`），当传入时使用上述 console=True 的 spec 构建，产出 `WindowsCleaner_console.exe`（可与主 exe 同目录或单独目录）。
- 在 [packaging/README_PACK.md](packaging/README_PACK.md) 中简短说明：若遇“无法打开、无托盘”，可运行 `WindowsCleaner_console.exe` 查看控制台输出与异常栈，并将完整报错信息提供给分析。

这样你本地“重新调试和打包”时，可优先跑 console 版，把控制台里的报错信息一并作为分析依据。

---

## 6. 代码检索与重新调试、打包的推荐顺序

- **检索**：已覆盖 [run.py](run.py)、[backend/main.py](backend/main.py)、[backend/services/tray_service.py](backend/services/tray_service.py)、[backend/core/logging_config.py](backend/core/logging_config.py)、[backend/core/constants.py](backend/core/constants.py)。无需再扩大范围即可落实上述改动。
- **实现顺序建议**：  
  1. 在 run.py 增加 bootstrap 日志与主流程 try/except + 步骤/异常写入；
  2. run_api() 内对 run_server 做 try/except 并写日志；
  3. 主流程中在启动 server 线程前调用 setup_logging()（并处理 import 失败时写 bootstrap）；
  4. tray_service.run_tray 内 ImportError 与 icon.run 异常写日志并可选弹窗；
  5. 增加 console 版 spec 与 build 参数并更新 README_PACK；
  6. 重新打包（含普通 exe 与 console exe），在你这台机上用 console 版复现一次，确认“出错也有报错信息可以给到你自己进行分析”；
  7. **调试步骤**：新增 docs/DEBUGGING.md（或 README 调试小节），写清从源码运行方式、日志位置、pytest 用法、推荐调试顺序；可选 scripts/run_api_only 脚本；
  8. **模拟打开与验证**：新增 backend/tests 中 API 配置往返测试（POST/GET config 含 disk_thresholds 与 cleanup_rules）；可选 monitor 规则执行单测、scripts/simulate_open_and_configure.py 及文档中的手动步骤；跑通一次“模拟打开→配置规则→验证生效”的完整流程并记录在文档中。

---

## 7. 小结（启动与可见性）

- **Bootstrap 日志**：最早、仅用标准库写 `%APPDATA%\\WindowsCleaner\\logs\\windows_cleaner.log`，记录启动与后续每步/异常。  
- **主线程与服务器线程**：关键步骤与所有未捕获异常都写入该日志（或统一 logger）。  
- **托盘**：不再静默 return，写日志并可选 MessageBox 提示查看日志。  
- **调试 exe**：提供带控制台的 `WindowsCleaner_console.exe` 便于你本地看报错并反馈。  
- **调试步骤（§8）**：文档化运行方式、日志、pytest、调试顺序，便于本人与二次开发 AI 复现问题。  
- **模拟打开与验证（§9）**：pytest 覆盖“配置规则并持久化”，可选脚本与文档完成一次“打开→配置磁盘清理规则→验证生效”的模拟流程。

按上述修改后，再执行一次完整重新打包与本地运行（优先跑 console 版），即可在“无法打开、无托盘”时从日志或控制台拿到明确报错信息用于分析。

---

## 8. 调试步骤完善（方便本人与二次开发 AI 调试）

**目标**：在文档和可选脚本中固化一套可复现的调试流程，便于人类与二次开发 AI 快速定位问题、验证改动。

**实现要点**：

- **新增调试文档** [docs/DEBUGGING.md](docs/DEBUGGING.md)（或 README 内「调试说明」小节），包含：
  - **从源码运行的几种方式**：  
    - 仅 API（无托盘、无窗口）：`py run.py --no-tray`，服务监听 127.0.0.1:8765，可直接用浏览器或 curl 访问 `/api/health`、`/api/config`、`/api/disk/drives` 等。  
    - 带托盘与自动开窗：`py run.py --gui`（需 pystray、PIL、可选 pywebview）。  
    - 打包后：普通 exe 无控制台；调试用 `WindowsCleaner_console.exe` 带控制台，便于查看 print 与未捕获异常。
  - **日志位置与查看**：日志文件路径 `%APPDATA%\WindowsCleaner\logs\windows_cleaner.log`，说明 bootstrap 与正常日志都写该文件；常见错误（如 ImportError、端口占用、托盘创建失败）对应日志中的关键字或栈信息。
  - **单元测试**：`pytest backend/tests/ -v`，简要说明各 test 文件覆盖的模块（config、disk、resource_guard、index_service 等），以及如何只跑单个文件/用例。
  - **推荐调试顺序**：1) 先 `py run.py --no-tray` 确认 API 与日志正常；2) 再试 `py run.py --gui` 看托盘与开窗；3) 若打包后异常，用 `WindowsCleaner_console.exe` 复现并查看控制台与日志。
- **可选**：在项目根目录提供 `scripts/run_api_only.bat` 或 `scripts/run_api_only.ps1`，内容为启动 `py run.py --no-tray` 并 echo 日志路径与 `http://127.0.0.1:8765`，便于 AI 或开发者一键“只起后端”做接口验证。

这样本人与二次开发 AI 可按文档步骤复现“打开→配置→验证”，并有一致的日志与运行方式便于分析。

---

## 9. 模拟打开、配置磁盘清理规则、并验证生效

**目标**：通过自动化测试 + 可选脚本，完成“模拟打开应用 → 配置磁盘清理规则（含磁盘阈值与清理规则）→ 验证配置已持久化且会被监控逻辑使用”，便于回归与二次开发时确认功能生效。

**实现要点**：

- **API 层配置往返测试（pytest）**  
  - 在 [backend/tests/](backend/tests/) 中新增或扩展用例（如 `test_api_config_rules.py`）：使用 FastAPI `TestClient` 挂载 [backend/main.py](backend/main.py) 的 `app`，在临时目录下操作配置（通过 monkeypatch 将 [backend/core/constants.CONFIG_DIR](backend/core/constants.py) 指向临时目录，避免污染用户配置）。  
  - 步骤：  
    1. `POST /api/config` 提交 body 包含 `disk_thresholds`（例如一条 `{ "drive_letter": "C", "free_percent_alert_below": 15 }`）和 `cleanup_rules`（例如一条 `{ "id": "r1", "target_path": "C:\\Temp", "rule_type": "large_file", "size_mb_min": 100, "auto_clean": false }`）。  
    2. `GET /api/config`，断言返回的 `disk_thresholds`、`cleanup_rules` 与提交一致（含字段如 drive_letter、free_percent_alert_below、target_path、rule_type、size_mb_min、auto_clean）。
  - 依赖：临时目录、现有 [backend/core/config](backend/core/config.py) 的 load/save 与 [backend/api/routes](backend/api/routes.py) 的 ConfigUpdateBody；无需真实启动 uvicorn。
- **监控逻辑“规则生效”的验证（可选、单元级）**  
  - 对 [backend/services/monitor_service.py](backend/services/monitor_service.py) 的 `run_rule_scan(rule)` 做单测：在临时目录下创建符合规则的文件（如大于 100MB 的占位文件或按扩展名），传入对应 rule dict，断言返回的 matches 非空且路径/大小符合预期；或对 `check_disk_thresholds` 在 mock 的 disk_usage 下断言会/不会调用 notify_alert。  
  - 这样可验证“配置的规则会被调度器执行”的逻辑正确，无需长时间跑后台。
- **模拟打开与配置的脚本（可选）**  
  - 新增脚本 [scripts/simulate_open_and_configure.py](scripts/simulate_open_and_configure.py)（或类似路径）：  
    1. 使用 `httpx` 或 `urllib` 轮询 `http://127.0.0.1:8765/api/health` 直到就绪（可设超时），若未就绪则提示“请先启动服务：py run.py --no-tray”。  
    2. `POST /api/config` 写入一条磁盘阈值（如全局 10% 或 C: 15%）和一条清理规则（如某存在路径、large_file 100MB、仅提醒）。  
    3. `GET /api/config` 断言返回中包含刚写入的阈值与规则。  
    4. 可选：`GET /api/disk/drives`、`POST /api/scan/rebuild-index` 等模拟用户操作，仅作接口可用性验证。
  - 脚本可被人类或 AI 直接运行，用于“不打开 GUI 也能验证配置与接口”的回归。
- **文档中的手动步骤**  
  - 在 [docs/DEBUGGING.md](docs/DEBUGGING.md) 中增加「模拟打开并配置规则」：1) 启动服务（API-only 或 GUI）；2) 浏览器打开 [http://127.0.0.1:8765；3](http://127.0.0.1:8765；3)) 在设置/规则页添加一条磁盘阈值和一条清理规则并保存；4) 刷新或再次打开配置页（或调用 GET /api/config）确认已保存；5) 说明定时任务会在内部间隔后执行 run_scheduled_rules/check_disk_thresholds，或通过脚本触发一次扫描以验证“规则生效”。

**验收**：跑通上述 pytest 用例 + 可选运行 simulate_open_and_configure.py（在服务已起或脚本内提示先起服务）后，能确认“配置磁盘清理规则并验证生效”的链路可用，便于本人与二次开发 AI 调试。